

(include "kit/macros")

(import-namespace kit)

(include "kit/header")

;; (include "./inc/generic"
;;          ;;"./inc/async"
;;          )



;; (change (#-> ((create Markdown))
;;              .parse
;;              (.save file)
;;              ))
;; (async-let ((test-dir (.find Fs.posts "./tests")))
;;   (.watch test-dir)
;;   (.on test-dir 'change (aprint "added")))









(macro in (  o k) [k " in " o])


(macro lit (...body) `(literal ...@(.map body global.lit-macros )))

(macro class  (name super-class body)
       "create an es6 style class."
       ["class " name
                 ...(if body (interleave " " [" extends" super-class ]) [])
                 " "
                 `(curly ...@(.map (get (or body super-class)
                                        "contents") global.lit-macros ))])

(macro loose-var (...body)
       (bulk-map body (=> (name value )
                          (if (.includes name.token ".")
                              `(assign @name @value)
                              `(var @name @value)))))


(macro def-pipe (name args ...body)
       `(def @name ($value ...@(get args 'contents))
          (pipe $value ...@body)))

(macro def-let (name args let-args ...body)
       `(def @name @args
          (let @let-args ...@body)))

(macro list-of (size ...body)
       `(let ((array []))
          (do-times @size
            (array.push (scoped ...@body))) array))


;; (var curry R.curry)

;; (macro then-pipe (p ...funcs)
;;        `(pipe @p
;;               ...@(.map funcs (=> (e) `(.then @e)))))


(meta

 (namespace interface)

 (var init-form   (fpipe (get 'contents)
                         first
                         (get  'token)
                         (=  "init")))

 (var not-init (fpipe init-form not ))

 ;;(var find-init-form (fpipe (.find  init-form) (or {contents []}) (get 'contents) rest))

 (var find-init-form (fpipe (.find  init-form)
                            (or {contents []})
                            (get 'contents)
                            rest))

 (def create-interface (name args body)

   (let ((init-body `(init @ args ...@(find-init-form body)))

         (lit-args (.filter body not-init)))

     `(.define Interface (quote @name) (lit @init-body ...@lit-args))))



 (def macros.create-interface (name args body)

   (let ((init-body `(init @ args ...@(find-init-form body)))

         (lit-args (.filter body not-init)))

     `(.define Interface
               (quote @name)
               (lit @init-body ...@lit-args))))

 (def-lit-macro def-interface (name args ...body)
   `(property @name (create-interface @name @args @body)))

 (def macros.def-interface (name args ...body)
   `(loose-var @name @(.create-interface macros name args body)))
 null)

(var Interface {})

(describe Interface

          ( *symbols {})
          ( *types {})

          (init (name
                 *obj
                 (*types {})
                 (*symbols {})))

          (def-generic define
              (name

               *obj *types *symbols

               ( *shares (or *obj.borrows *obj.shares []))
               ( *ext (or *obj.extend {}))
               ( *build *obj.build))


            (if (in  *symbols name)

                (mixin *obj (get *types (get *symbols name)))
                (.create this name *obj)))

          (def-generic create

              (name

               *obj *types *symbols

               (*shares (or *obj.borrows *obj.shares []))
               (*ext (or *obj.extend {}))
               (*build *obj.build)
               (*symbol (Symbol name)))

            (collect m (extend  *ext (mixin  [ (lit name (symbol *symbol)) (dots *shares) ] *obj))

                     (set *symbols name *symbol)
                     (set *types  *symbol m)

                     (if *build (.build m )))))
