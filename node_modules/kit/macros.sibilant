(namespace kit )

(macro transpile-name (name)
       `(get (sibilant (get (first (get @name "contents")) 'token)) 'js))

(macro dotted? (token) `(= (get @token "type") "dots"))

(include "./inc/macros"
         "./inc/description.sibilant"
         "./inc/lit-macros")

(meta
 (def transpile.string (node)
   (pipe node.token
         (.replace (regex "(\\r\\n|\\n|\\r)" 'gm) "\\n\"+\""))))

(macro chain-promise (p ...rest)
       (if (empty? rest)
           p
           `(then-do @p (chain-promise ...@rest))))

(macro async-let (vars ...body)
       "A let style form that captures the resolved values of the variables defined."
       `(then (Promise.all [ ...@(map vars.contents (v) (second v.contents))])
              [...@(map vars.contents (v) (first v.contents))]
              ...@body))
(meta
 (namespace kit)

 (include "kit/macros")
 (import-namespace kit)

 (var modules (new Set))

 (macro add-to-module-lookup (path)
        `(let ( (p "/") (inc @ (or path (process.cwd))))
           (require! 'path)
           (assign module.paths
                   [...module.paths
                    ...(pipe
                        (.split inc path.sep)
                        (.map (=> (el)
                                  (var r (path.join p "node_modules"))
                                  (assign p (path.join p el))
                                  r))
                        (.filter (=> (e) (not (.includes module.paths e))))
                        )])
           null))

 (macro clear-source-cache (...paths) (.map paths (=> (p) (delete (get sibilant.source-cache p))))
        null)
 (def macros.unload (...paths)
   (pipe paths
         (.map (=> (p) [p (eval p.token)]))

         (.filter (=> ([p path]) (pipe path modules.has  )))

         (.map (=> ([p path])

                   (print "unloading" path)
                   (.delete modules path)
                   (clear-source-cache path)))))

 (def macros.reload (...paths)
   (.map paths (#-> (tap macros.unload)
                    macros.load)))

 (def macros.load (...paths)
   (pipe paths
         (.map (=> (p) [p (eval p.token)]))

         (.filter (=> ([p path]) (pipe path modules.has not )))

         (.map (=> ([p path])
                   (.add modules path)
                   (print "loading" path)
                   `(include @p))))))

(alias-macro async-let alet )

(macro async-let* (vars ...body)
       "Same as async-let, except each variables definition can reference the variables declared before them."
       (if (> vars.contents.length 1)
           `(async-let (@(first vars.contents))
              (async-let* (...@(rest vars.contents))
                          ...@body))))

(alias-macro async-let* alet*)
